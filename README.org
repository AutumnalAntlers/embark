* embark - Emacs Mini-Buffer Actions Rooted in Keymaps


This package provides a pairs of commands, =embark-act= and
=embark-exit-and-act=, to execute actions on the top minibuffer
completion canidate: the one that would be chosen by
=minibuffer-force-complete=. Additionally, =embark-act= can act on the
completion candidate at point in the completions buffer. You should
bind both of them in =minibuffer-local-completion-map= and also bind
=embark-act= in =completion-list-mode-map=.

You can use any command that reads from the minibuffer as an action
and the target of the action will be inserted at the first minibuffer
prompt.  After running =embark-act= all of your keybindings and even
=execute-extended-command= can be used to run a command. 

But for additional convenience, =embark-act= also activates an extra
keymap for you, where you can bind commonly used actions to single
keys. There is a keymap for each "type" of completion. By default
=embark= recognizes the following types of completion: file names,
buffers and symbols (used for functions, variables and commands). The
classification is configurable, see the variable =embark-classifiers=.

For any given type there is a corresponding keymap as noted in
=embark-keymap-alist=. For example, for the completion category =file=, by
default the corresponding keymap is =embark-file-map=. In this keymap
you can bind normal commands you might want to use on file names. For
example, by default =embark-file-map= binds =delete-file= to "d",
=rename-file= to "r" and =copy-file= to "c", among other bindings.

The default keymaps that come with =embark= all set =embark-general-map=
as their parent, so that the actions bound there are available no
matter what type of completion you are in the middle of. By default
this includes bindings to save the current candidate in the kill
ring and to insert the current candidate in the previously selected
buffer (the buffer that was current when you executed a command that
opened up the minibuffer).

You can read about the [[https://github.com/oantolin/embark/wiki/Default-Actions][default actions and their keybindings]]
on the GitHub project wiki.

** Running some setup after injecting the target

If you want to customize what happens after the target is inserted at
the minibuffer prompt of an action, you can use the =embark-setup=
property of the action command. That property should be a hook, that
is, a function or list of functions, to be run after inserting the
target into the minibuffer.

For example, =shell-command= and =async-shell-command= can be useful as
actions during file completion. For these commands it would be useful
to leave point at the beginning of the minibuffer, before the inserted
file name, so you can type the command. That can be arranged as
follows:

#+begin_src emacs-lisp
(put 'async-shell-command 'embark-setup 'beginning-of-line)
(put 'shell-command 'embark-setup 'beginning-of-line)
#+end_src

Since this particular configuration is so useful, you don't have to
put the above code in your init file; an even better version comes
with =embark=: a space is inserted automatically too. Take this as an
example of the kind of post-processing you might want to do with the
=embark-setup= property.

If you want some setup run for all commands add it to
=embark-setup-hook=. Note that this hook only runs for commands which
have no =embark-setup= property.

For another example see the next section.

** Not waiting for confirmation

By default, for most commands =embark= inserts the target of the action
into the next minibuffer prompt and "presses =RET=" for you. This
"pressing =RET=" is done by the command =embark-ratify=, which is the
default value of =embark-setup-hook=. For a few commands that are deemed
hard to undo (like commands to delete a file or directory, or to kill
a buffer), =embark= comes with an overriding =embark-setup= property to
wait for the user to manually press =RET=.

If you disagree with these defaults, you can, for example, have =embark=
kill buffers without confirmation:

#+begin_src emacs-lisp
(put 'kill-buffer 'embark-setup 'embark-ratify)
#+end_src

Or, maybe you want to be prudent and have all commands wait for you to
press =RET= after inspecting the minibuffer. In that case:

#+begin_src emacs-lisp
  (setq embark-setup-hook nil)
#+end_src

** Actions that do not read from the minibuffer

Additionally you can write your own commands that do not read from
the minibuffer but act on the current target anyway: just use the
=embark-target= function (exactly once!: it "self-destructs") to
retrieve the current target. See the definitions of =embark-insert= or
=embark-save= for examples.

** Showing a reminder of available actions

If you wish to see a reminder of which actions are available, you can
install [[https://github.com/justbur/emacs-which-key][which-key]] and use =which-key-mode= with the
=which-key-show-transient-maps= variable set to =t=. You may want to
unclutter the display by removing all of the keybindings for the
universal prefix arguments, namely =C-u= and the digits and minus (as
well as their numeric keypad counterparts):

#+begin_src emacs-lisp
  (push '(("^[0-9-]\\|kp-[0-9]\\|kp-subtract\\|C-u$" . nil) . ignore)
        which-key-replacement-alist)
#+end_src

** Creating your own keymaps

All internal keymaps are generated by a helper function =embark-keymap=
that you can use it to generate keymaps for new categories in
=embark-keymap-alist= or for any other purpose! For example a simple
version of the file action keymap coud be defined as follows:

#+BEGIN_SRC emacs-lisp
(defvar embark-file-map
  (embark-keymap
   '(("d" . delete-file)
     ("r" . rename-file)
     ("c" . copy-file))
   embark-general-map))
#+END_SRC

